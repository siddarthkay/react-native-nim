"""
CMake configuration generator for Android NDK build.
"""

from typing import List

from .base import CodeGenerator
from ..models import NimFunction
from ..config import GeneratorConfig


class CMakeGenerator(CodeGenerator):
    """Generates CMakeLists.txt for Android NDK build."""

    def __init__(self, functions: List[NimFunction], config: GeneratorConfig):
        super().__init__(functions, config)

    @staticmethod
    def _generate_cmake_header(description: str) -> str:
        """Generate CMake-style header with # comments."""
        return f"""# Auto-generated {description}
# DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py
# This file will be overwritten when bindings are regenerated

"""

    def generate(self) -> str:
        """Generate dynamic CMakeLists.txt based on configuration and function analysis."""
        cmake_config = self.config.data.get('cmake', {})

        code = self._generate_cmake_header("CMakeLists.txt for Android NDK")

        # Dynamic CMake version and project
        min_version = cmake_config.get('min_version', '3.13')
        project_name = cmake_config.get('project_name', 'NimBridge')

        code += f"""cmake_minimum_required(VERSION {min_version})
project({project_name})

set(PACKAGE_NAME "{self.config.library_name}")

"""

        # Dynamic cache paths from config
        cache_paths = cmake_config.get('nim_cache_paths', [
            "../../../../../../nim/cache_android",
            "${CMAKE_CURRENT_SOURCE_DIR}/../../../../../../nim/cache_android",
            "${CMAKE_SOURCE_DIR}/../../../nim/cache_android"
        ])

        code += "# Auto-discover Nim compiled C files from configured locations\nset(POSSIBLE_CACHE_DIRS\n"
        for path in cache_paths:
            code += f'    "{path}"\n'
        code += ")\n\n"

        # File discovery logic (this part is genuinely dynamic)
        code += """set(NIM_C_FILES "")
foreach(CACHE_DIR ${POSSIBLE_CACHE_DIRS})
    file(GLOB_RECURSE FOUND_FILES "${CACHE_DIR}/*.c")
    if(FOUND_FILES)
        list(APPEND NIM_C_FILES ${FOUND_FILES})
        message(STATUS "Found Nim C files in: ${CACHE_DIR}")
        break()
    endif()
endforeach()

if(NOT NIM_C_FILES)
    message(FATAL_ERROR "No Nim C files found in any of these locations: ${POSSIBLE_CACHE_DIRS}")
endif()

"""

        # Analyze functions to determine required sources
        cpp_files = ["NimBridge.cpp"]
        if self._has_string_functions():
            code += "# String handling detected - additional memory management may be needed\n"
        if self._has_math_functions():
            code += "# Math functions detected - ensuring math library linkage\n"

        code += f"""# Create shared library with auto-generated sources
add_library(
        ${{PACKAGE_NAME}}
        SHARED
        {' '.join(cpp_files)}
        ${{NIM_C_FILES}}
)

"""

        # Dynamic include directories
        include_dirs = cmake_config.get('include_directories', [
            ".", "${NIM_CACHE_DIR}", "${NIM_SOURCE_DIR}"
        ])

        code += """# Auto-determine include directories
set(NIM_CACHE_DIR "")
foreach(CACHE_DIR ${POSSIBLE_CACHE_DIRS})
    if(EXISTS "${CACHE_DIR}")
        set(NIM_CACHE_DIR "${CACHE_DIR}")
        break()
    endif()
endforeach()

# Get the nim source directory (parent of cache directory)
get_filename_component(NIM_SOURCE_DIR "${NIM_CACHE_DIR}" DIRECTORY)

target_include_directories(
        ${PACKAGE_NAME}
        PRIVATE
"""
        for inc_dir in include_dirs:
            code += f'        "{inc_dir}"\n'
        code += ")\n\n"

        # Dynamic compiler definitions
        defines = cmake_config.get('defines', {})
        code += self._generate_compile_definitions(defines)

        # Dynamic compiler flags
        compiler_flags = cmake_config.get('compiler_flags', [])
        if compiler_flags:
            code += f"""# Additional compiler flags
target_compile_options(${{PACKAGE_NAME}} PRIVATE
"""
            for flag in compiler_flags:
                code += f"    {flag}\n"
            code += ")\n\n"

        # Dynamic link libraries
        link_libs = cmake_config.get('link_libraries', ['android', 'log', 'm', 'atomic'])
        if self._has_math_functions() and 'm' not in link_libs:
            link_libs.append('m')

        code += f"""# Link required libraries
target_link_libraries(
        ${{PACKAGE_NAME}}
"""
        for lib in link_libs:
            code += f"        {lib}\n"
        code += ")\n"

        return code

    def _generate_compile_definitions(self, defines: dict) -> str:
        """Generate compile definitions dynamically."""
        if not defines:
            return ""

        code = "# Compiler definitions\n"

        # Handle NIM_INTBITS automatically
        nim_intbits = defines.get('NIM_INTBITS', 'auto')
        if nim_intbits == 'auto':
            code += """if(ANDROID_ABI STREQUAL "arm64-v8a" OR ANDROID_ABI STREQUAL "x86_64")
    target_compile_definitions(${PACKAGE_NAME} PRIVATE 
        -DNIM_INTBITS=64
    )
else()
    # 32-bit architectures (armeabi-v7a, x86)
    target_compile_definitions(${PACKAGE_NAME} PRIVATE 
        -DNIM_INTBITS=32
    )
endif()

"""
        else:
            code += f'target_compile_definitions(${{PACKAGE_NAME}} PRIVATE -DNIM_INTBITS={nim_intbits})\n'

        # Add other defines
        other_defines = []
        for key, value in defines.items():
            if key != 'NIM_INTBITS':
                if isinstance(value, bool):
                    if value:
                        other_defines.append(f"-D{key}")
                else:
                    other_defines.append(f"-D{key}={value}")

        if other_defines:
            code += f"target_compile_definitions(${{PACKAGE_NAME}} PRIVATE\n"
            for define in other_defines:
                code += f"    {define}\n"
            code += ")\n\n"

        return code

    def _has_string_functions(self) -> bool:
        """Check if any functions return strings."""
        return any(func.return_type in ['cstring', 'string'] for func in self.functions)

    def _has_math_functions(self) -> bool:
        """Check if any functions perform mathematical operations."""
        math_functions = {'fibonacci', 'prime', 'factorize', 'add', 'multiply', 'sqrt', 'pow'}
        return any(any(math_word in func.name.lower() for math_word in math_functions)
                  for func in self.functions)