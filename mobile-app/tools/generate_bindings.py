#!/usr/bin/env python3
"""
Automatic binding generator for Nim -> React Native
Parses Nim exported functions and generates all necessary bridge code
"""

import re
import os
import sys
from pathlib import Path

class NimFunction:
    def __init__(self, name, return_type, params, memory_type=None):
        self.name = name
        self.return_type = return_type
        self.params = params  # List of (name, type) tuples
        self.memory_type = memory_type  # 'literal' or 'allocated' for string returns

def parse_nim_exports(nim_file):
    """Parse Nim file and extract exported functions"""
    functions = []
    
    with open(nim_file, 'r') as f:
        content = f.read()
    
    # Regex to match exported Nim procs with optional doc comments
    # Captures: proc name, parameters, return type, and the full proc definition
    pattern = r'proc\s+(\w+)\*\s*\((.*?)\)\s*:\s*(\w+)\s*{[^}]*exportc[^}]*}'
    
    for match in re.finditer(pattern, content, re.MULTILINE | re.DOTALL):
        func_name = match.group(1)
        params_str = match.group(2)
        return_type = match.group(3)
        
        # Check for memory annotation in doc comment
        memory_type = None
        if return_type in ['cstring', 'string']:
            # Look for doc comment before the function
            func_start_pos = match.start()
            # Look backwards for ## comments
            lines_before = content[:func_start_pos].split('\n')
            # Check the last few lines before the function for annotations
            for i in range(len(lines_before) - 1, max(0, len(lines_before) - 5), -1):
                line = lines_before[i].strip()
                if '@literal' in line:
                    memory_type = 'literal'
                    break
                elif '@allocated' in line:
                    memory_type = 'allocated'
                    break
                elif line and not line.startswith('##'):
                    # Stop looking if we hit non-comment content
                    break
            
            # If no annotation found, detect from implementation
            if memory_type is None:
                func_start = match.end()
                # Find the function body (simple heuristic - look for next proc or end of file)
                next_proc = content.find('\nproc ', func_start)
                func_body = content[func_start:next_proc if next_proc != -1 else len(content)]
                if 'allocCString' in func_body:
                    memory_type = 'allocated'
                else:
                    memory_type = 'literal'
        
        # Parse parameters
        params = []
        if params_str.strip():
            for param in params_str.split(','):
                param = param.strip()
                if ':' in param:
                    name, ptype = param.split(':', 1)
                    params.append((name.strip(), ptype.strip()))
        
        functions.append(NimFunction(func_name, return_type, params, memory_type))
    
    return functions

def nim_to_cpp_type(nim_type):
    """Convert Nim type to C++ type"""
    type_map = {
        'cstring': 'NCSTRING',
        'cint': 'int',
        'int': 'int',
        'int64': 'long long',
        'string': 'NCSTRING',
        'bool': 'int',
        'float': 'double',
    }
    return type_map.get(nim_type, nim_type)

def nim_to_objc_type(nim_type):
    """Convert Nim type to Objective-C type"""
    type_map = {
        'cstring': 'NSString *',
        'string': 'NSString *',
        'cint': 'NSNumber *',
        'int': 'NSNumber *',
        'int64': 'NSNumber *',
        'bool': 'NSNumber *',
        'float': 'NSNumber *',
    }
    return type_map.get(nim_type, 'id')

def nim_to_ts_type(nim_type):
    """Convert Nim type to TypeScript type"""
    type_map = {
        'cstring': 'string',
        'string': 'string',
        'cint': 'number',
        'int': 'number',
        'int64': 'number',
        'bool': 'boolean',
        'float': 'number',
    }
    return type_map.get(nim_type, 'any')

def generate_cpp_wrapper(functions):
    """Generate C++ wrapper code"""
    code = """// Auto-generated C++ wrapper for Nim functions
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

#include <string>
#include <cstring>

extern "C" {
    typedef char* NCSTRING;
    
    // Nim runtime
    void NimMain(void);
    void mobileNimInit(void);
    void mobileNimShutdown(void);
    
    // Generated function declarations
"""
    
    # Add function declarations
    for func in functions:
        ret_type = nim_to_cpp_type(func.return_type)
        params_str = ', '.join([f"{nim_to_cpp_type(ptype)} {name}" 
                               for name, ptype in func.params])
        code += f"    {ret_type} {func.name}({params_str});\n"
    
    code += "    \n    // Memory management\n"
    code += "    void freeString(NCSTRING s);\n"
    code += "}\n"
    
    return code

def generate_objc_bridge(functions):
    """Generate Objective-C++ bridge code"""
    code = """// Auto-generated Objective-C++ bridge
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

#import "NimBridge.h"
#include "nim_functions.h"

@implementation NimBridge

RCT_EXPORT_MODULE()

+ (BOOL)requiresMainQueueSetup
{
    return NO;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        // Initialize Nim runtime
        NimMain();
        mobileNimInit();
    }
    return self;
}

- (void)dealloc
{
    mobileNimShutdown();
}

// Generated method exports
"""
    
    for func in functions:
        ret_type = nim_to_objc_type(func.return_type)
        
        # Build method signature
        if not func.params:
            method_sig = func.name
        else:
            parts = []
            for i, (name, ptype) in enumerate(func.params):
                objc_type = nim_to_objc_type(ptype)
                if i == 0:
                    parts.append(f"{func.name}:(nonnull {objc_type}){name}")
                else:
                    parts.append(f"with{name.capitalize()}:(nonnull {objc_type}){name}")
            method_sig = ' '.join(parts)
        
        code += f"RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD({ret_type}, {method_sig})\n"
        code += "{\n"
        
        # Call the C++ function
        if func.return_type in ['cstring', 'string']:
            args = ', '.join([f"(NCSTRING)[{name} UTF8String]" if ptype in ['cstring', 'string'] 
                            else f"[{name} intValue]" if ptype in ['cint', 'int']
                            else name
                            for name, ptype in func.params])
            code += f"    NCSTRING result = {func.name}({args});\n"
            # Check memory type from parsed annotations
            if func.memory_type == 'allocated':
                code += f"    NSString *objcString = result ? [NSString stringWithUTF8String:result] : @\"\";\n"
                code += f"    if (result) freeString(result);\n"
                code += f"    return objcString;\n"
            else:  # literal or unknown (default to literal for safety)
                code += f"    return result ? [NSString stringWithUTF8String:result] : @\"\";\n"
        elif func.return_type == 'int64':
            args = ', '.join([f"[{name} intValue]" if ptype in ['cint', 'int']
                            else f"(NCSTRING)[{name} UTF8String]" if ptype in ['cstring', 'string']
                            else name
                            for name, ptype in func.params])
            code += f"    long long result = {func.name}({args});\n"
            code += f"    return @(result);\n"
        elif func.return_type in ['cint', 'int', 'bool']:
            args = ', '.join([f"[{name} intValue]" if ptype in ['cint', 'int']
                            else f"(NCSTRING)[{name} UTF8String]" if ptype in ['cstring', 'string']
                            else name
                            for name, ptype in func.params])
            code += f"    int result = {func.name}({args});\n"
            code += f"    return @(result);\n"
        
        code += "}\n\n"
    
    code += "@end\n"
    
    return code

def generate_typescript_interface(functions):
    """Generate TypeScript interface"""
    code = """// Auto-generated TypeScript interface for Nim bridge
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

export interface NimBridge {
"""
    
    for func in functions:
        ret_type = nim_to_ts_type(func.return_type)
        params_str = ', '.join([f"{name}: {nim_to_ts_type(ptype)}" 
                               for name, ptype in func.params])
        code += f"  {func.name}({params_str}): {ret_type};\n"
    
    code += "}\n"
    
    return code

def nim_to_kotlin_type(nim_type):
    """Convert Nim type to Kotlin type"""
    type_map = {
        'cstring': 'String',
        'string': 'String', 
        'cint': 'Double',
        'int': 'Double',
        'int64': 'Double',
        'bool': 'Double',
        'float': 'Double',
    }
    return type_map.get(nim_type, 'String')

def generate_android_kotlin_module(functions):
    """Generate Android Kotlin module"""
    code = """// Auto-generated Kotlin module for Nim bridge
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

package com.nimbridge

import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.module.annotations.ReactModule

@ReactModule(name = NimBridgeModule.NAME)
class NimBridgeModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
    
    companion object {
        const val NAME = "NimBridge"
        
        init {
            try {
                System.loadLibrary("nim_functions")
                android.util.Log.d("NimBridge", "Native library nim_functions loaded successfully")
            } catch (e: Exception) {
                android.util.Log.e("NimBridge", "Failed to load native library nim_functions: ${e.message}")
                e.printStackTrace()
            }
        }
        
"""
    
    # Add native method declarations
    for func in functions:
        if func.return_type in ['cstring', 'string']:
            ret_type = "String"
        elif func.return_type == 'int64':
            ret_type = "Long"
        else:
            ret_type = "Int"
        
        params_list = []
        for name, ptype in func.params:
            if ptype in ['cint', 'int']:
                params_list.append(f"{name}: Int")
            elif ptype in ['cstring', 'string']:
                params_list.append(f"{name}: String")
            else:
                params_list.append(f"{name}: Int")
        params_str = ', '.join(params_list)
        
        code += f"        @JvmStatic\n"
        code += f"        private external fun native{func.name[0].upper() + func.name[1:]}({params_str}): {ret_type}\n"
    
    code += "    }\n"
    code += "    \n"
    code += "    override fun getName(): String = NAME\n\n"
    
    # Add React methods
    for func in functions:
        # Build method parameters with correct Kotlin types
        method_params = []
        for name, ptype in func.params:
            if ptype in ['cint', 'int']:
                method_params.append(f"{name}: Double")
            elif ptype in ['cstring', 'string']:
                method_params.append(f"{name}: String")
            else:
                method_params.append(f"{name}: Double")
        params_str = ', '.join(method_params)
        
        # Determine return type
        if func.return_type in ['cstring', 'string']:
            kotlin_ret_type = "String"
        else:
            kotlin_ret_type = "Double"
        
        code += f"    @ReactMethod(isBlockingSynchronousMethod = true)\n"
        code += f"    fun {func.name}({params_str}): {kotlin_ret_type} {{\n"
        code += f"        return try {{\n"
        
        # Build native call with proper type conversions
        args = []
        for name, ptype in func.params:
            if ptype in ['cint', 'int']:
                args.append(f"{name}.toInt()")
            else:
                args.append(name)
        args_str = ', '.join(args)
        
        if func.return_type in ['cstring', 'string']:
            code += f"            native{func.name[0].upper() + func.name[1:]}({args_str})\n"
        else:
            code += f"            native{func.name[0].upper() + func.name[1:]}({args_str}).toDouble()\n"
        
        code += f"        }} catch (e: Exception) {{\n"
        if func.return_type in ['cstring', 'string']:
            code += f'            "Error: ${{e.message}}"\n'
        else:
            code += f"            0.0\n"
        code += f"        }}\n"
        code += f"    }}\n"
    
    code += "}"
    
    return code

def generate_android_kotlin_package():
    """Generate Android Kotlin package file"""
    code = """// Auto-generated Kotlin package for Nim bridge
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

package com.nimbridge

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class NimBridgePackage : ReactPackage {
    
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(NimBridgeModule(reactContext))
    }
    
    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}"""
    return code

def generate_android_jni_cpp(functions):
    """Generate Android JNI C++ bridge"""
    code = """// Auto-generated JNI C++ bridge for Android
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

#include <jni.h>
#include <string>

// Import the Nim functions
extern "C" {
"""
    
    # Add function declarations
    for func in functions:
        params_str = ', '.join([f"const char* {name}" if ptype in ['cstring', 'string']
                               else f"int {name}"
                               for name, ptype in func.params])
        if func.return_type in ['cstring', 'string']:
            ret_type = "const char*"
        elif func.return_type == 'int64':
            ret_type = "long long"
        else:
            ret_type = "int"
        code += f"    {ret_type} {func.name}({params_str});\n"
    
    code += """    void mobileNimInit();
    void mobileNimShutdown();
    void freeString(const char* s);
}

// Initialize Nim when the library loads
static bool nimInitialized = false;

void initializeNim() {
    if (!nimInitialized) {
        mobileNimInit();
        nimInitialized = true;
    }
}

"""
    
    # Add JNI methods
    for func in functions:
        class_name = "com_nimbridge_NimBridgeModule"
        method_name = f"native{func.name[0].upper() + func.name[1:]}"
        
        # Build JNI signature
        jni_params = []
        for name, ptype in func.params:
            if ptype in ['cstring', 'string']:
                jni_params.append(f"jstring {name}")
            else:
                jni_params.append(f"jint {name}")
        
        jni_params_str = ', '.join(['JNIEnv *env', 'jclass clazz'] + jni_params)
        
        if func.return_type in ['cstring', 'string']:
            ret_type = "jstring"
            code += f"extern \"C\" JNIEXPORT {ret_type} JNICALL\n"
            code += f"Java_{class_name}_{method_name}({jni_params_str}) {{\n"
            code += f"    initializeNim();\n"
            
            # Handle string parameters
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    code += f"    const char* {name}Str = env->GetStringUTFChars({name}, 0);\n"
            
            # Build actual call with converted params
            actual_params = []
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    actual_params.append(f"{name}Str")
                else:
                    actual_params.append(name)
            actual_params_str = ', '.join(actual_params)
            
            code += f"    const char* result = {func.name}({actual_params_str});\n"
            
            # Release string parameters
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    code += f"    env->ReleaseStringUTFChars({name}, {name}Str);\n"
            
            # Check memory type from parsed annotations
            if func.memory_type == 'allocated':
                code += f"    jstring javaString = env->NewStringUTF(result);\n"
                code += f"    if (result) freeString(result);\n"
                code += f"    return javaString;\n"
            else:  # literal or unknown (default to literal for safety)
                code += f"    return env->NewStringUTF(result);\n"
        elif func.return_type == 'int64':
            ret_type = "jlong"
            code += f"extern \"C\" JNIEXPORT {ret_type} JNICALL\n"
            code += f"Java_{class_name}_{method_name}({jni_params_str}) {{\n"
            code += f"    initializeNim();\n"
            
            # Handle string parameters properly
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    code += f"    const char* {name}Str = env->GetStringUTFChars({name}, 0);\n"
            
            # Build actual call with converted params
            actual_params = []
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    actual_params.append(f"{name}Str")
                else:
                    actual_params.append(name)
            actual_params_str = ', '.join(actual_params)
            
            code += f"    long long result = {func.name}({actual_params_str});\n"
            
            # Release string parameters
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    code += f"    env->ReleaseStringUTFChars({name}, {name}Str);\n"
            
            code += f"    return (jlong)result;\n"
        else:
            ret_type = "jint"
            code += f"extern \"C\" JNIEXPORT {ret_type} JNICALL\n"
            code += f"Java_{class_name}_{method_name}({jni_params_str}) {{\n"
            code += f"    initializeNim();\n"
            
            # Handle string parameters properly
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    code += f"    const char* {name}Str = env->GetStringUTFChars({name}, 0);\n"
            
            # Build actual call with converted params
            actual_params = []
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    actual_params.append(f"{name}Str")
                else:
                    actual_params.append(name)
            actual_params_str = ', '.join(actual_params)
            
            code += f"    int result = {func.name}({actual_params_str});\n"
            
            # Release string parameters
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    code += f"    env->ReleaseStringUTFChars({name}, {name}Str);\n"
            
            code += f"    return result;\n"
        
        code += f"}}\n\n"
    
    return code

def main():
    # Find all Nim files with exports
    nim_dir = Path(__file__).parent.parent / "nim"
    nim_files = list(nim_dir.glob("*.nim"))
    
    all_functions = []
    for nim_file in nim_files:
        functions = parse_nim_exports(nim_file)
        all_functions.extend(functions)
        if functions:
            print(f"Found {len(functions)} exported functions in {nim_file.name}")
    
    if not all_functions:
        print("No exported functions found!")
        return
    
    # Generate all bridge files
    output_dir = Path(__file__).parent.parent / "modules" / "nim-bridge"
    
    # C++ wrapper
    cpp_code = generate_cpp_wrapper(all_functions)
    cpp_file = output_dir / "ios" / "nim_functions.h"
    cpp_file.write_text(cpp_code)
    print(f"Generated {cpp_file}")
    
    # Objective-C++ bridge
    objc_code = generate_objc_bridge(all_functions)
    objc_file = output_dir / "ios" / "NimBridge.mm"
    objc_file.write_text(objc_code)
    print(f"Generated {objc_file}")
    
    # TypeScript interface
    ts_code = generate_typescript_interface(all_functions)
    ts_file = output_dir / "src" / "NimBridge.types.ts"
    ts_file.parent.mkdir(exist_ok=True)
    ts_file.write_text(ts_code)
    print(f"Generated {ts_file}")
    
    # Android Kotlin module
    kotlin_code = generate_android_kotlin_module(all_functions)
    kotlin_file = output_dir / "android" / "src" / "main" / "java" / "com" / "nimbridge" / "NimBridgeModule.kt"
    kotlin_file.parent.mkdir(parents=True, exist_ok=True)
    kotlin_file.write_text(kotlin_code)
    print(f"Generated {kotlin_file}")
    
    # Android Kotlin package
    kotlin_package_code = generate_android_kotlin_package()
    kotlin_package_file = output_dir / "android" / "src" / "main" / "java" / "com" / "nimbridge" / "NimBridgePackage.kt"
    kotlin_package_file.write_text(kotlin_package_code)
    print(f"Generated {kotlin_package_file}")
    
    # Android JNI C++ bridge
    jni_code = generate_android_jni_cpp(all_functions)
    jni_file = output_dir / "android" / "src" / "main" / "cpp" / "NimBridge.cpp"
    jni_file.parent.mkdir(parents=True, exist_ok=True)
    jni_file.write_text(jni_code)
    print(f"Generated {jni_file}")
    
    print(f"\n✅ Successfully generated bindings for {len(all_functions)} functions!")
    print("\nGenerated files:")
    print("  iOS: nim_functions.h, NimBridge.mm")
    print("  Android: NimBridgeModule.kt, NimBridge.cpp")
    print("  TypeScript: NimBridge.types.ts")
    print("\nNext steps:")
    print("1. Review the generated files")
    print("2. Run 'pod install' in ios/ directory")
    print("3. Rebuild the app")

if __name__ == "__main__":
    main()