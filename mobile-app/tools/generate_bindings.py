#!/usr/bin/env python3
"""
Automatic binding generator for Nim -> React Native
Parses Nim exported functions and generates all necessary bridge code
"""

import re
import os
import sys
from pathlib import Path

class NimFunction:
    def __init__(self, name, return_type, params):
        self.name = name
        self.return_type = return_type
        self.params = params  # List of (name, type) tuples

def parse_nim_exports(nim_file):
    """Parse Nim file and extract exported functions"""
    functions = []
    
    with open(nim_file, 'r') as f:
        content = f.read()
    
    # Regex to match exported Nim procs
    # proc functionName*(param: type, param2: type2): returnType {.exportc.}
    pattern = r'proc\s+(\w+)\*\s*\((.*?)\)\s*:\s*(\w+)\s*{[^}]*exportc[^}]*}'
    
    for match in re.finditer(pattern, content, re.MULTILINE | re.DOTALL):
        func_name = match.group(1)
        params_str = match.group(2)
        return_type = match.group(3)
        
        # Parse parameters
        params = []
        if params_str.strip():
            for param in params_str.split(','):
                param = param.strip()
                if ':' in param:
                    name, ptype = param.split(':', 1)
                    params.append((name.strip(), ptype.strip()))
        
        functions.append(NimFunction(func_name, return_type, params))
    
    return functions

def nim_to_cpp_type(nim_type):
    """Convert Nim type to C++ type"""
    type_map = {
        'cstring': 'NCSTRING',
        'cint': 'int',
        'int': 'int',
        'string': 'NCSTRING',
        'bool': 'int',
        'float': 'double',
    }
    return type_map.get(nim_type, nim_type)

def nim_to_objc_type(nim_type):
    """Convert Nim type to Objective-C type"""
    type_map = {
        'cstring': 'NSString *',
        'string': 'NSString *',
        'cint': 'NSNumber *',
        'int': 'NSNumber *',
        'bool': 'NSNumber *',
        'float': 'NSNumber *',
    }
    return type_map.get(nim_type, 'id')

def nim_to_ts_type(nim_type):
    """Convert Nim type to TypeScript type"""
    type_map = {
        'cstring': 'string',
        'string': 'string',
        'cint': 'number',
        'int': 'number',
        'bool': 'boolean',
        'float': 'number',
    }
    return type_map.get(nim_type, 'any')

def generate_cpp_wrapper(functions):
    """Generate C++ wrapper code"""
    code = """// Auto-generated C++ wrapper for Nim functions
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

#include <string>
#include <cstring>

extern "C" {
    typedef char* NCSTRING;
    
    // Nim runtime
    void NimMain(void);
    void mobileNimInit(void);
    void mobileNimShutdown(void);
    
    // Generated function declarations
"""
    
    # Add function declarations
    for func in functions:
        ret_type = nim_to_cpp_type(func.return_type)
        params_str = ', '.join([f"{nim_to_cpp_type(ptype)} {name}" 
                               for name, ptype in func.params])
        code += f"    {ret_type} {func.name}({params_str});\n"
    
    code += "}\n"
    
    return code

def generate_objc_bridge(functions):
    """Generate Objective-C++ bridge code"""
    code = """// Auto-generated Objective-C++ bridge
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

#import "NimBridge.h"
#include "nim_functions.h"

@implementation NimBridge

RCT_EXPORT_MODULE()

+ (BOOL)requiresMainQueueSetup
{
    return NO;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        // Initialize Nim runtime
        NimMain();
        mobileNimInit();
    }
    return self;
}

- (void)dealloc
{
    mobileNimShutdown();
}

// Generated method exports
"""
    
    for func in functions:
        ret_type = nim_to_objc_type(func.return_type)
        
        # Build method signature
        if not func.params:
            method_sig = func.name
        else:
            parts = []
            for i, (name, ptype) in enumerate(func.params):
                objc_type = nim_to_objc_type(ptype)
                if i == 0:
                    parts.append(f"{func.name}:(nonnull {objc_type}){name}")
                else:
                    parts.append(f"with{name.capitalize()}:(nonnull {objc_type}){name}")
            method_sig = ' '.join(parts)
        
        code += f"RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD({ret_type}, {method_sig})\n"
        code += "{\n"
        
        # Call the C++ function
        if func.return_type in ['cstring', 'string']:
            args = ', '.join([f"(NCSTRING)[{name} UTF8String]" if ptype in ['cstring', 'string'] 
                            else f"[{name} intValue]" if ptype in ['cint', 'int']
                            else name
                            for name, ptype in func.params])
            code += f"    NCSTRING result = {func.name}({args});\n"
            code += f"    return result ? [NSString stringWithUTF8String:result] : @\"\";\n"
        elif func.return_type in ['cint', 'int', 'bool']:
            args = ', '.join([f"[{name} intValue]" if ptype in ['cint', 'int']
                            else f"(NCSTRING)[{name} UTF8String]" if ptype in ['cstring', 'string']
                            else name
                            for name, ptype in func.params])
            code += f"    int result = {func.name}({args});\n"
            code += f"    return @(result);\n"
        
        code += "}\n\n"
    
    code += "@end\n"
    
    return code

def generate_typescript_interface(functions):
    """Generate TypeScript interface"""
    code = """// Auto-generated TypeScript interface for Nim bridge
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

export interface NimBridge {
"""
    
    for func in functions:
        ret_type = nim_to_ts_type(func.return_type)
        params_str = ', '.join([f"{name}: {nim_to_ts_type(ptype)}" 
                               for name, ptype in func.params])
        code += f"  {func.name}({params_str}): {ret_type};\n"
    
    code += "}\n"
    
    return code

def main():
    # Find all Nim files with exports
    nim_dir = Path(__file__).parent.parent / "nim"
    nim_files = list(nim_dir.glob("*.nim"))
    
    all_functions = []
    for nim_file in nim_files:
        functions = parse_nim_exports(nim_file)
        all_functions.extend(functions)
        if functions:
            print(f"Found {len(functions)} exported functions in {nim_file.name}")
    
    if not all_functions:
        print("No exported functions found!")
        return
    
    # Generate all bridge files
    output_dir = Path(__file__).parent.parent / "modules" / "nim-bridge"
    
    # C++ wrapper
    cpp_code = generate_cpp_wrapper(all_functions)
    cpp_file = output_dir / "ios" / "nim_functions.h"
    cpp_file.write_text(cpp_code)
    print(f"Generated {cpp_file}")
    
    # Objective-C++ bridge
    objc_code = generate_objc_bridge(all_functions)
    objc_file = output_dir / "ios" / "NimBridge.mm"
    objc_file.write_text(objc_code)
    print(f"Generated {objc_file}")
    
    # TypeScript interface
    ts_code = generate_typescript_interface(all_functions)
    ts_file = output_dir / "src" / "NimBridge.types.ts"
    ts_file.parent.mkdir(exist_ok=True)
    ts_file.write_text(ts_code)
    print(f"Generated {ts_file}")
    
    print(f"\nâœ… Successfully generated bindings for {len(all_functions)} functions!")
    print("\nNext steps:")
    print("1. Review the generated files")
    print("2. Run 'pod install' in ios/ directory")
    print("3. Rebuild the app")

if __name__ == "__main__":
    main()