#!/usr/bin/env python3
"""
Automatic binding generator for Nim -> React Native
Parses Nim exported functions and generates all necessary bridge code
"""

import re
import os
import sys
from pathlib import Path

class NimFunction:
    def __init__(self, name, return_type, params):
        self.name = name
        self.return_type = return_type
        self.params = params  # List of (name, type) tuples

def parse_nim_exports(nim_file):
    """Parse Nim file and extract exported functions"""
    functions = []
    
    with open(nim_file, 'r') as f:
        content = f.read()
    
    # Regex to match exported Nim procs
    # proc functionName*(param: type, param2: type2): returnType {.exportc.}
    pattern = r'proc\s+(\w+)\*\s*\((.*?)\)\s*:\s*(\w+)\s*{[^}]*exportc[^}]*}'
    
    for match in re.finditer(pattern, content, re.MULTILINE | re.DOTALL):
        func_name = match.group(1)
        params_str = match.group(2)
        return_type = match.group(3)
        
        # Parse parameters
        params = []
        if params_str.strip():
            for param in params_str.split(','):
                param = param.strip()
                if ':' in param:
                    name, ptype = param.split(':', 1)
                    params.append((name.strip(), ptype.strip()))
        
        functions.append(NimFunction(func_name, return_type, params))
    
    return functions

def nim_to_cpp_type(nim_type):
    """Convert Nim type to C++ type"""
    type_map = {
        'cstring': 'NCSTRING',
        'cint': 'int',
        'int': 'int',
        'int64': 'long long',
        'string': 'NCSTRING',
        'bool': 'int',
        'float': 'double',
    }
    return type_map.get(nim_type, nim_type)

def nim_to_objc_type(nim_type):
    """Convert Nim type to Objective-C type"""
    type_map = {
        'cstring': 'NSString *',
        'string': 'NSString *',
        'cint': 'NSNumber *',
        'int': 'NSNumber *',
        'int64': 'NSNumber *',
        'bool': 'NSNumber *',
        'float': 'NSNumber *',
    }
    return type_map.get(nim_type, 'id')

def nim_to_ts_type(nim_type):
    """Convert Nim type to TypeScript type"""
    type_map = {
        'cstring': 'string',
        'string': 'string',
        'cint': 'number',
        'int': 'number',
        'int64': 'number',
        'bool': 'boolean',
        'float': 'number',
    }
    return type_map.get(nim_type, 'any')

def generate_cpp_wrapper(functions):
    """Generate C++ wrapper code"""
    code = """// Auto-generated C++ wrapper for Nim functions
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

#include <string>
#include <cstring>

extern "C" {
    typedef char* NCSTRING;
    
    // Nim runtime
    void NimMain(void);
    void mobileNimInit(void);
    void mobileNimShutdown(void);
    
    // Generated function declarations
"""
    
    # Add function declarations
    for func in functions:
        ret_type = nim_to_cpp_type(func.return_type)
        params_str = ', '.join([f"{nim_to_cpp_type(ptype)} {name}" 
                               for name, ptype in func.params])
        code += f"    {ret_type} {func.name}({params_str});\n"
    
    code += "    \n    // Memory management\n"
    code += "    void freeString(NCSTRING s);\n"
    code += "}\n"
    
    return code

def generate_objc_bridge(functions):
    """Generate Objective-C++ bridge code"""
    code = """// Auto-generated Objective-C++ bridge
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

#import "NimBridge.h"
#include "nim_functions.h"

@implementation NimBridge

RCT_EXPORT_MODULE()

+ (BOOL)requiresMainQueueSetup
{
    return NO;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        // Initialize Nim runtime
        NimMain();
        mobileNimInit();
    }
    return self;
}

- (void)dealloc
{
    mobileNimShutdown();
}

// Generated method exports
"""
    
    for func in functions:
        ret_type = nim_to_objc_type(func.return_type)
        
        # Build method signature
        if not func.params:
            method_sig = func.name
        else:
            parts = []
            for i, (name, ptype) in enumerate(func.params):
                objc_type = nim_to_objc_type(ptype)
                if i == 0:
                    parts.append(f"{func.name}:(nonnull {objc_type}){name}")
                else:
                    parts.append(f"with{name.capitalize()}:(nonnull {objc_type}){name}")
            method_sig = ' '.join(parts)
        
        code += f"RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD({ret_type}, {method_sig})\n"
        code += "{\n"
        
        # Call the C++ function
        if func.return_type in ['cstring', 'string']:
            args = ', '.join([f"(NCSTRING)[{name} UTF8String]" if ptype in ['cstring', 'string'] 
                            else f"[{name} intValue]" if ptype in ['cint', 'int']
                            else name
                            for name, ptype in func.params])
            code += f"    NCSTRING result = {func.name}({args});\n"
            # Check if this function allocates memory (not a literal)
            if func.name in ['mobileFactorize', 'mobileCreateUser', 'getSystemInfo']:
                code += f"    NSString *objcString = result ? [NSString stringWithUTF8String:result] : @\"\";\n"
                code += f"    if (result) freeString(result);\n"
                code += f"    return objcString;\n"
            else:
                code += f"    return result ? [NSString stringWithUTF8String:result] : @\"\";\n"
        elif func.return_type == 'int64':
            args = ', '.join([f"[{name} intValue]" if ptype in ['cint', 'int']
                            else f"(NCSTRING)[{name} UTF8String]" if ptype in ['cstring', 'string']
                            else name
                            for name, ptype in func.params])
            code += f"    long long result = {func.name}({args});\n"
            code += f"    return @(result);\n"
        elif func.return_type in ['cint', 'int', 'bool']:
            args = ', '.join([f"[{name} intValue]" if ptype in ['cint', 'int']
                            else f"(NCSTRING)[{name} UTF8String]" if ptype in ['cstring', 'string']
                            else name
                            for name, ptype in func.params])
            code += f"    int result = {func.name}({args});\n"
            code += f"    return @(result);\n"
        
        code += "}\n\n"
    
    code += "@end\n"
    
    return code

def generate_typescript_interface(functions):
    """Generate TypeScript interface"""
    code = """// Auto-generated TypeScript interface for Nim bridge
// DO NOT EDIT MANUALLY - Generated by tools/generate_bindings.py

export interface NimBridge {
"""
    
    for func in functions:
        ret_type = nim_to_ts_type(func.return_type)
        params_str = ', '.join([f"{name}: {nim_to_ts_type(ptype)}" 
                               for name, ptype in func.params])
        code += f"  {func.name}({params_str}): {ret_type};\n"
    
    code += "}\n"
    
    return code

def nim_to_java_type(nim_type):
    """Convert Nim type to Java type"""
    type_map = {
        'cstring': 'String',
        'string': 'String', 
        'cint': 'Double',
        'int': 'Double',
        'int64': 'Double',
        'bool': 'Double',
        'float': 'Double',
    }
    return type_map.get(nim_type, 'String')

def generate_android_java_module(functions):
    """Generate Android Java module"""
    code = """package com.nimbridge;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.Promise;
import com.facebook.react.module.annotations.ReactModule;

@ReactModule(name = NimBridgeModule.NAME)
public class NimBridgeModule extends ReactContextBaseJavaModule {
    public static final String NAME = "NimBridge";

    // Load the native library
    static {
        try {
            System.loadLibrary("nim_functions");
            android.util.Log.d("NimBridge", "Native library nim_functions loaded successfully");
        } catch (Exception e) {
            android.util.Log.e("NimBridge", "Failed to load native library nim_functions: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public NimBridgeModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    @Override
    public String getName() {
        return NAME;
    }

    // Native method declarations
"""
    
    # Add native method declarations
    for func in functions:
        params_str = ', '.join([f"{nim_to_java_type(ptype)} {name}" if ptype not in ['cstring', 'string'] 
                               else f"String {name}"
                               for name, ptype in func.params])
        if func.return_type in ['cstring', 'string']:
            ret_type = "String"
        elif func.return_type == 'int64':
            ret_type = "long"
        else:
            ret_type = "int"
        
        code += f"    private static native {ret_type} native{func.name[0].upper() + func.name[1:]}({', '.join([f'int {name}' if ptype in ['cint', 'int'] else f'String {name}' for name, ptype in func.params])});\n"
    
    code += "\n"
    
    # Add React methods
    for func in functions:
        # Build method parameters with correct Java types
        method_params = []
        for name, ptype in func.params:
            if ptype in ['cint', 'int']:
                method_params.append(f"Double {name}")
            elif ptype in ['cstring', 'string']:
                method_params.append(f"String {name}")
            else:
                method_params.append(f"Double {name}")
        params_str = ', '.join(method_params)
        
        # Determine return type
        if func.return_type in ['cstring', 'string']:
            java_ret_type = "String"
        else:
            java_ret_type = "Double"
        
        code += f"    @ReactMethod(isBlockingSynchronousMethod = true)\n"
        code += f"    public {java_ret_type} {func.name}({params_str}) {{\n"
        code += f"        try {{\n"
        
        # Build native call with proper type conversions
        args = []
        for name, ptype in func.params:
            if ptype in ['cint', 'int']:
                args.append(f"{name}.intValue()")
            else:
                args.append(name)
        args_str = ', '.join(args)
        
        if func.return_type in ['cstring', 'string']:
            code += f"            return native{func.name[0].upper() + func.name[1:]}({args_str});\n"
        else:
            code += f"            return (double) native{func.name[0].upper() + func.name[1:]}({args_str});\n"
        
        code += f"        }} catch (Exception e) {{\n"
        if func.return_type in ['cstring', 'string']:
            code += f'            return "Error: " + e.getMessage();\n'
        else:
            code += f"            return 0.0;\n"
        code += f"        }}\n"
        code += f"    }}\n\n"
    
    code += "}\n"
    
    return code

def generate_android_jni_cpp(functions):
    """Generate Android JNI C++ bridge"""
    code = """#include <jni.h>
#include <string>

// Import the Nim functions
extern "C" {
"""
    
    # Add function declarations
    for func in functions:
        params_str = ', '.join([f"const char* {name}" if ptype in ['cstring', 'string']
                               else f"int {name}"
                               for name, ptype in func.params])
        if func.return_type in ['cstring', 'string']:
            ret_type = "const char*"
        elif func.return_type == 'int64':
            ret_type = "long long"
        else:
            ret_type = "int"
        code += f"    {ret_type} {func.name}({params_str});\n"
    
    code += """    void mobileNimInit();
    void mobileNimShutdown();
    void freeString(const char* s);
}

// Initialize Nim when the library loads
static bool nimInitialized = false;

void initializeNim() {
    if (!nimInitialized) {
        mobileNimInit();
        nimInitialized = true;
    }
}

"""
    
    # Add JNI methods
    for func in functions:
        class_name = "com_nimbridge_NimBridgeModule"
        method_name = f"native{func.name[0].upper() + func.name[1:]}"
        
        # Build JNI signature
        jni_params = []
        call_params = []
        for name, ptype in func.params:
            if ptype in ['cstring', 'string']:
                jni_params.append(f"jstring {name}")
                call_params.append(f'env->GetStringUTFChars({name}, 0)')
            else:
                jni_params.append(f"jint {name}")
                call_params.append(name)
        
        jni_params_str = ', '.join(['JNIEnv *env', 'jclass clazz'] + jni_params)
        call_params_str = ', '.join(call_params)
        
        if func.return_type in ['cstring', 'string']:
            ret_type = "jstring"
            code += f"extern \"C\" JNIEXPORT {ret_type} JNICALL\n"
            code += f"Java_{class_name}_{method_name}({jni_params_str}) {{\n"
            code += f"    initializeNim();\n"
            
            # Handle string parameters
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    code += f"    const char* {name}Str = env->GetStringUTFChars({name}, 0);\n"
            
            # Build actual call with converted params
            actual_params = []
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    actual_params.append(f"{name}Str")
                else:
                    actual_params.append(name)
            actual_params_str = ', '.join(actual_params)
            
            code += f"    const char* result = {func.name}({actual_params_str});\n"
            
            # Release string parameters
            for name, ptype in func.params:
                if ptype in ['cstring', 'string']:
                    code += f"    env->ReleaseStringUTFChars({name}, {name}Str);\n"
            
            # Free allocated strings for functions that allocate memory
            if func.name in ['mobileFactorize', 'mobileCreateUser', 'getSystemInfo']:
                code += f"    jstring javaString = env->NewStringUTF(result);\n"
                code += f"    if (result) freeString(result);\n"
                code += f"    return javaString;\n"
            else:
                code += f"    return env->NewStringUTF(result);\n"
        elif func.return_type == 'int64':
            ret_type = "jlong"
            code += f"extern \"C\" JNIEXPORT {ret_type} JNICALL\n"
            code += f"Java_{class_name}_{method_name}({jni_params_str}) {{\n"
            code += f"    initializeNim();\n"
            code += f"    return (jlong){func.name}({call_params_str});\n"
        else:
            ret_type = "jint"
            code += f"extern \"C\" JNIEXPORT {ret_type} JNICALL\n"
            code += f"Java_{class_name}_{method_name}({jni_params_str}) {{\n"
            code += f"    initializeNim();\n"
            code += f"    return {func.name}({call_params_str});\n"
        
        code += f"}}\n\n"
    
    return code

def main():
    # Find all Nim files with exports
    nim_dir = Path(__file__).parent.parent / "nim"
    nim_files = list(nim_dir.glob("*.nim"))
    
    all_functions = []
    for nim_file in nim_files:
        functions = parse_nim_exports(nim_file)
        all_functions.extend(functions)
        if functions:
            print(f"Found {len(functions)} exported functions in {nim_file.name}")
    
    if not all_functions:
        print("No exported functions found!")
        return
    
    # Generate all bridge files
    output_dir = Path(__file__).parent.parent / "modules" / "nim-bridge"
    
    # C++ wrapper
    cpp_code = generate_cpp_wrapper(all_functions)
    cpp_file = output_dir / "ios" / "nim_functions.h"
    cpp_file.write_text(cpp_code)
    print(f"Generated {cpp_file}")
    
    # Objective-C++ bridge
    objc_code = generate_objc_bridge(all_functions)
    objc_file = output_dir / "ios" / "NimBridge.mm"
    objc_file.write_text(objc_code)
    print(f"Generated {objc_file}")
    
    # TypeScript interface
    ts_code = generate_typescript_interface(all_functions)
    ts_file = output_dir / "src" / "NimBridge.types.ts"
    ts_file.parent.mkdir(exist_ok=True)
    ts_file.write_text(ts_code)
    print(f"Generated {ts_file}")
    
    # Android Java module
    java_code = generate_android_java_module(all_functions)
    java_file = output_dir / "android" / "src" / "main" / "java" / "com" / "nimbridge" / "NimBridgeModule.java"
    java_file.parent.mkdir(parents=True, exist_ok=True)
    java_file.write_text(java_code)
    print(f"Generated {java_file}")
    
    # Android JNI C++ bridge
    jni_code = generate_android_jni_cpp(all_functions)
    jni_file = output_dir / "android" / "src" / "main" / "cpp" / "NimBridge.cpp"
    jni_file.parent.mkdir(parents=True, exist_ok=True)
    jni_file.write_text(jni_code)
    print(f"Generated {jni_file}")
    
    print(f"\n✅ Successfully generated bindings for {len(all_functions)} functions!")
    print("\nGenerated files:")
    print("  iOS: nim_functions.h, NimBridge.mm")
    print("  Android: NimBridgeModule.java, NimBridge.cpp")
    print("  TypeScript: NimBridge.types.ts")
    print("\nNext steps:")
    print("1. Review the generated files")
    print("2. Run 'pod install' in ios/ directory")
    print("3. Rebuild the app")

if __name__ == "__main__":
    main()