/* Generated by Nim Compiler v2.2.0 */
/* Compiled for: iOS, arm64, clang */
/* Command for C compiler:
   clang++ -c -std=gnu++17 -funsigned-char  -pthread -fPIC  -O3 -fno-ident  -fPIC  -I/opt/homebrew/Cellar/nim/2.2.0/nim/lib -I/Users/siddarthkumar/code/siddarthkay/react-native-nim/nim-core/src -o /Users/siddarthkumar/code/siddarthkay/react-native-nim/bindings/ios/@m..@s..@s..@s..@s..@s.nimble@spkgs2@sstew-0.4.1-996d9c058ee078d0209a5f539424a0235683918c@sstew@sstrings.nim.cpp.o /Users/siddarthkumar/code/siddarthkay/react-native-nim/bindings/ios/@m..@s..@s..@s..@s..@s.nimble@spkgs2@sstew-0.4.1-996d9c058ee078d0209a5f539424a0235683918c@sstew@sstrings.nim.cpp */
#define NIM_INTBITS 64
#define NIM_EmulateOverflowChecks

#include "nimbase.h"
#include <string.h>
#undef LANGUAGE_C
#undef MIPSEB
#undef MIPSEL
#undef PPC
#undef R3000
#undef R4000
#undef i386
#undef linux
#undef mips
#undef near
#undef far
#undef powerpc
#undef unix
struct NimStrPayload;
struct NimStringV2;
struct NimStrPayload {
	NI cap;
	NIM_CHAR data[SEQ_DECL_SIZE];
};
struct NimStringV2 {
	NI len;
	NimStrPayload* p;
};
static N_INLINE(NIM_BOOL, nimAddInt)(NI a_p0, NI b_p1, NI* res_p2);
N_LIB_PRIVATE N_NOINLINE(void, raiseOverflow)(void);
N_LIB_PRIVATE N_NOINLINE(void, raiseRangeErrorI)(NI64 i_p0, NI64 a_p1, NI64 b_p2);
N_LIB_PRIVATE N_NIMCALL(void, setLengthStrV2)(NimStringV2& s_p0, NI newLen_p1);
static N_INLINE(void, copyMem__system_u1726)(void* dest_p0, void* source_p1, NI size_p2);
static N_INLINE(void, nimCopyMem)(void* dest_p0, void* source_p1, NI size_p2);
N_LIB_PRIVATE N_NOINLINE(void, raiseIndexError2)(NI i_p0, NI n_p1);
static N_INLINE(NIM_BOOL, nimAddInt)(NI a_p0, NI b_p1, NI* res_p2) {
	NIM_BOOL result;
	result = (NIM_BOOL)0;
	NI r = ((NI) ((NU)((NU64)(((NU) (a_p0))) + (NU64)(((NU) (b_p1))))));
	{
		NIM_BOOL T3_;
		T3_ = (NIM_BOOL)0;
		T3_ = (((NI)0) <= (NI)(r ^ a_p0));
		if (T3_) goto LA4_;
		T3_ = (((NI)0) <= (NI)(r ^ b_p1));
LA4_: ;
		if (!T3_) goto LA5_;
{		(*res_p2) = r;
}	}
	goto LA1_;
LA5_: ;
	{
		result = NIM_TRUE;
	}
LA1_: ;
	return result;
}
static N_INLINE(void, nimCopyMem)(void* dest_p0, void* source_p1, NI size_p2) {
	auto T1_ = memcpy(dest_p0, source_p1, ((size_t) (size_p2)));
}
static N_INLINE(void, copyMem__system_u1726)(void* dest_p0, void* source_p1, NI size_p2) {
	nimCopyMem(dest_p0, source_p1, size_p2);
}
N_LIB_PRIVATE N_NIMCALL(void, add__pkgZstewZstrings_u1)(NimStringV2& s_p0, NIM_CHAR* data_p1, NI data_p1Len_0) {
	{
		NI TM__rxM6Xe9bxtrvcRCkWCJvuhA_2;
		if (!(((NI)0) < data_p1Len_0)) goto LA3_;
{		NI prevEnd = s_p0.len;
		if (nimAddInt(prevEnd, data_p1Len_0, &TM__rxM6Xe9bxtrvcRCkWCJvuhA_2)) { raiseOverflow(); 		};
		if (((NI)(TM__rxM6Xe9bxtrvcRCkWCJvuhA_2)) < ((NI)0) || ((NI)(TM__rxM6Xe9bxtrvcRCkWCJvuhA_2)) > ((NI)IL64(9223372036854775807))){ raiseRangeErrorI((NI)(TM__rxM6Xe9bxtrvcRCkWCJvuhA_2), ((NI)0), ((NI)IL64(9223372036854775807))); 		}
		setLengthStrV2(s_p0, ((NI)(TM__rxM6Xe9bxtrvcRCkWCJvuhA_2)));
		if (prevEnd < 0 || prevEnd >= s_p0.len){ raiseIndexError2(prevEnd,s_p0.len-1); 		}
		if (((NI)0) < 0 || ((NI)0) >= data_p1Len_0){ raiseIndexError2(((NI)0),data_p1Len_0-1); 		}
		if ((data_p1Len_0) < ((NI)0) || (data_p1Len_0) > ((NI)IL64(9223372036854775807))){ raiseRangeErrorI(data_p1Len_0, ((NI)0), ((NI)IL64(9223372036854775807))); 		}
		copyMem__system_u1726(((void*) ((&s_p0.p->data[prevEnd]))), ((void*) ((&data_p1[((NI)0)]))), (data_p1Len_0));
}	}
LA3_: ;
}
